# 6. 순수 함수적 상태



상태(state)를 다루는 순수 함수적 프로그램을 작성하는 방법을 알아보자. 

난수발생(random number generation)분야의 예를 이용할 것이다. 

이번 장의 목표는 **임의의** 상태 있는(stateful) API를 순수함수적으로 만드는데 쓰이는 기본 패턴들을 익히는 것이다.



#### 6.1 부수 효과를 이용한 난수 발생

```scala
val rng = new scala.util.Random

rng.nextDouble
=> 0.9.xxxx

rng.nextDouble
=> 0.8xxxx

rng.nextInt
=> -623454

rng.nextInt(10)// 0이상 9이하의 값
=> 4
```

난수 발생기 객체 rng에는 메서드 호출 때마다 갱신되는 어떤 내부 상태가 존재 한다고 가정 할 수 있다. 그렇지 않다면 nextInt나 nextDouble을 호출할 때마다 같은 값을 얻게 될 것이기 때문이다. 

상태갱신은 부수효과로서 수행되므로 이 메서드들은 참조에 투명하지 않다. -> 참조에 투명하지 않은 함수는 검사, 합성, 모듈화가 어렵고, 쉽게 병렬화할 수도 없다. 

```scala
def rollDie: Int={
    val rng = new scala.util.Random
    rng.nextInt(6) // 0이상 5이하의 난수
}
```

원하는 것은 1에서 6사이의 값을 원하지만, 실제로는 0에서 5사이의 값이 나온다. 

이 예에서는 버그가 명백하고 재현하기도 어렵지 않다. 그러나 메서드가 훨씬 복잡하고 버그가 훨씬 미묘한 상황도 얼마든지 상상할 수 있다. 

하지만 이런 부수효과를 발생하는 코드에서는 **실패**한 검사를 **재현하기가 쉽지 않다**. 그래서 **애초에 부수효과를 피해**야 한다.



#### 6.2 순수 함수적 난수 발생

참조 투명성을 되찾는 관건은 상태갱신을 **명시적으로 드러내는 것**이다.

즉 상태를 부수효과로서 갱신하지 않고, 그냥 새 상태를 발생한 난수와 함께 돌려주면 된다. 



```scala
trait RNG{
    def nextInt:(Int, RNG)
}
```

- 무작위 Int 값을 생성해야 한다. 
- 발생한 난수만 돌려주는 대신, 이 인터페이스는 난수와 새 상태를 돌려주고 기존 상태는 수정하지 않는다. 
- 그냥 다음 상태를 호출자에게 돌려줄 뿐이다. 
- 새 상태로 무엇을 할 것인지는 전적으로 nextInt 호출자의 마음이다. 
- 이 API의 사용자가 난수 발생기 자체의 구현에 대해서는 아무것도 모른다는 점에서, 상태는 발생기안에 **캡슐화** 되어 있다. 

```scala
case class SimpleRNG(seed: Long) extends RNG{
    def nextInt:(Int, RNG) = {
        val newSeed = (seed * 0x5DEECE66DL + 0xBL) & 0xFFFFFFFFFFFFL
        //&는 비트 단위 논리곱(AND) 이다. 현재 종잣값을 이용해서 새 종잣값을 만든다.
        val nextRNG = SimpleRNG(newSeed)
        // 다음 상태(새 종잣값으로 생성한 RNG 인스턴스)
        val n = (newSeed>>>16).toInt
        //>>>는 빈자리를 0으로 채우는 이진 오른쪽 자리이동이다. 값n은 새 의사난수 정수이다.
        (n,nextRNG)
        //반환값은 의사난수 정수와 다음 발생기 상태를 담은 튜플이다. 
    }
}
```

다음은 REPL에서 이API를 사용한 예이다. 

```scala
val rng = SimpleRNG(42) // 임의의 종잣값으로 42

val (n1, rng2) = rng.nextInt // rng.nextInt가 돌려준 쌍을 분해해서 두개의 값을 선언하는 구문. 
=> Int = 16159453
=> RNG = SimpleRNG(1059025)

val(n2, n3) = rng2.nextInt
=> Int = -1281479697
=> RNG = SimpleRNG(1978293)
```

이 예를 여러 번 되풀이 해서 실행해도 항상 같은 값이 나온다.

다시 말해 이 API는 순수하다. 



#### 6.3 상태 있는 API를 순순하게 만들기 

겉보기에 상태 있는 API를 순수하게 만드는 문제와 그 해법이 난수 발생에만 국한된 것은 아니다. (API가 실제로 뭔가를 변이하는 대신 다음 상태를 계산하게 하는 것.)

```scala
class Foo{
    private var s: FooState = ...
    def bar:Bar
    def baz:Int
}
```

- bar와 baz가 각각 나름의 방식으로 s를 변이한다고 하자. 
- 한 상태에서 다음 상태로의 전이를 명시적으로 드러내는 과정을 기계적으로 진행해서 이 API를 순수함수적 API로 변환할 수 있다.

```scala
trait Foo{
    def bar:(Bar,Foo)
    def baz:(Int,Foo)
}
```

- 이 패턴을 적용한다는 것은 계산된 다음 상태를 프로그램의 나머지 부분에 전달하는 책임을 호출자가 가지게 되는것을 의미한다. 

이러한 API를 직접 사용하는 것이 얼마나 번거로울지, 공통으로 추출할 수 있는 부분이 있는지 살펴 보자. 



#### 6.4 상태 동작을 위한 더 나은 API

앞의 구현들을 살펴보면 모든 함수가 어떤 형식 A 에 대해 RNG => (A,RNG)형태의 형식을 사용한다는 공통 패턴을 발견할 수 있다. 한 RNG 상태를 다른 RNG상태로 변환한다는 점에서, 이런 종류의 함수를 **상태동작(state action)**또는 또는 **상태 전이**(state transition) 라고 부른다. 

이 상태동작들을 이번 절에서 작성해 볼 고차 함수인 **조합기(combinator)**를 이용해서 조합할 수 있다. 

상태를 호출자가 직접 전달하는 것은 지루하고 반복적이므로, 조합기가 자동으로 한 동작에서 다른 동작으로 상태를 넘겨주게 하는 것이 바람직 하다. 

```scala
type Rand[+A] = RNG => (A,RNG)

val int: Rand[Int] = _.nextInt
```

- RNG의 nextInt 같은 메서드를 이 새로운 형식의 값으로 만들 수 있다.



Rand 동작들을 조합하되 RNG 상태들을 명시적으로 전달하지 않아도 되는 조합기를 작성하는 것이 가능하다. 

다음은 주어진 RNG를 사용하지 않고 그대로 전달하는, 가장 간단한 형태의 RNG 상태 전이인 unit 동작이다. 

```scala
def unit[A](a:A):Rand[A]= {
    rng=>(a,rng)
}
```



또한 상태 동작의 출력을 변환하되 상태 자체는 수정하지 않는 map도 생각할 수 있다.

```scala
def map[A,B](s:Rand[A])(f:A=>B):Rand[B] = {
    rng=>{
        val (a, rng2) = s(rng)
        (f(a), rng2)
    }
}
```



map의 용법을 보여주는 예로 nonNegativeInt를 재사용 해서 0보다 크거나 같고 2로 나누어 지는 Int를 발생하는 함수 nonNegativeEven이다.

```scala
def nonNegativeEven:Rand[Int] = {
    map(nonNegativeInt)(i=>i-i%2)
}
```



#####6.4.1 상태 동작들의 조합

map2를 한 번만 작성해 두면 이를 이용해서 임의의 RNG상태 동작들을 조합할 수 있다.

```scala
def bot[A,B](ra:Rand[A],rb:Rand[B]):Rand[(A,B)]= 
	map2(ra,rb),((_,_))
```



#####6.4.2 내포된 상태 동작

지금까지 예에서 하나의 패턴이 보일 것이다. 이를 잘 추출한다면 RNG값을 명시적으로 언급하거나 전달하지 않는 구현이 가능하다. 

이와 같이 만들어진 함수들을 이용하여 앞에서 만들었던 주사위rollDie를 다시 만들 수 있다. 

그리고 동일한 난수 발생기를 이용하면 앞서 발생했던 실패 상황을 신뢰성 있게 재현할 수 있다. 이제는 상태가 사용 후 파괴되는 것을 걱정할 필요가 없다. -> 따라서 버그는 간단히 교정할 수 있게 된다. 



####6.5 일반적 상태 동작 자료 형식

지금까지 작성한 함수들은 난수 발생에만 국한 된 것이 전혀 아니다. 

이들은 상태 동작에 대해 작용하는 범용 함수들로, 상태의 구체적인 종류는 신경쓰지 않는다. 예를 들어 map은 자신이RNG상태 동작을 다루는지 상관하지 않으며, 따라서 이 함수에 다음과 같은 좀 더 일반적인 서명을 부여할 수 있다.

```scala
def map[S,A,B](a:S=>(A,S))(f:A=>B):S=>(B,S)
```



이제 임의의 상태를 처리할 수 있는 , Rand보다 더 일반적인 형식을 생각 해보자.

```scala
type State[S,+A]= S=>(A,S)
```

여기서 State는 **어떤 상태를 유지하는 계산**, 즉 **상태동작** 또는 **상태 전이**를 대표한다. 심지어 **명령문**(statement)을 대표한다고 할 수도 있다. 이를 다음과 같이 함수를 감싼 독립적인 클래스의 형태로 작성해도 좋다.

```scala
case class State[S,+A](run:S=>(A,S))
```

어떤 형태인지는 중요하지 않다. 중요한 것은 이제 상태 있는 프로그램의 공통 패턴들을 갈무리하는 범용 함수를 작성하는데 사용할 수 있는 단일 한, 범용적인 형식이 생겼다는 점이다. 

마지막으로 Rand는 그냥 State의 alias로 두면 된다. 

```scala
type Rand[A] = State[RNG,A]
```



#### 6.6 순수 함수적 명령식 프로그래밍

특정한 패턴을 따르는 함수들을 작성했다. 예제들은 상태 동작을 실행하고, 그 결과를 val에 배정하고, 그val을 사용하는 또 다른 상태 동작을 실행하고, 그 결과를 또 다른 val에 배정하는 등으로 이어졌다. 그런데 그런 방식은 **명령식** 프로그래밍과 아주 비슷하다. 

명령식 프로그래밍 패러다임에서 하나의 프로그램은 일련의 명령문들로 이루어 지며, 각 명령문은 프로그램의 상태를 수정할 수 있다. 앞에서 한 것이 바로 그런 방식이다. 

단 실제로는 명령문이 아니라 상태동작 State이고, State는 사실 함수 이다. 함수로서의 상태동작은 그냥 인수를 받음으로써 현재 프로그램 상태를 읽고 , 그냥 값을 돌려줌으로써 프로그램의 상태를 수정한다. 



다음 예를 생각해 보자,

```scala
val ns: Rand[List[Int]] = 
	int.flatMap(x=> //int는 하나의 정수 난수를 발생하는 Rand[Int]형식의 값이다.
               int.flatMap(y=>
                          ints(x).map(xs=>// ints(x)는 길이가 x  인 목록을 생성한다.
                                     xs.map(_%y))))// 목록의 모든 요소를 y로 나눈 나머지로 치환한다.
```



그런데 이 코드는 작동방식을 이해하기가 좀 어렵다. 다행히 map과 flatMap이 정의되어 있으므로, for-함축을 이용해서 명령식 스타일을 복구할 수 있다. 

```scala
val ns: Rand[List[Int]] = for{ 
    x <- int //정수 난수 x 를 발생한다.
    y <- int // 또 다른 정수 난수 y를 발생한다. 
    xs <- ints(x) // 길이가 x 인 목록 xs 를 생성한다.
} yield xs.map(_%y)// xs의 각 요소를 y로 나눈 나머지로 치환한 목록을 돌려준다. 
```

이 코드는 읽기가 훨씬 쉽다. 이 코드가 어떤 상태를 유지하는 명령식 프로그램이라는 점이 코드의 형태 자체에 잘 반영되어 있기 때문이다. 

